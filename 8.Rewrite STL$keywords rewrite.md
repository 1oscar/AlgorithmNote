##8.Rewrite STL$keywords Rewrite
###*Rewrite STL
Ex1:[Leetcode:Implement strStr()](oj.leetcode.com/problems/implement-strstr/)

从前向后比对，实现

```cpp
class Solution {
public:
    char *strStr(char *haystack, char *needle) {
        int len1 = strlen(haystack);
        int len2 = strlen(needle);
        if (len1 < len2)
            return NULL;
        if (len2 == 0)
            return haystack;
        char* p2 = haystack;
        for (int i = 0; i < len1 - len2 + 1; i++) {
            char* p1 = needle;
            char* p_old = (char*) p2;
            while (*p1 && *p2) {
                if (*p1 == *p2) {
                    p1++;
                    p2++;
                } else
                    break;
            }
            if (!*p1)
                return p_old;
            p2 = p_old + 1;
        }
        return NULL;
    }
};
```
  
Ex2:[Leetcode:String to Integer (atoi)](oj.leetcode.com/problems/string-to-integer-atoi/)  
主要判断溢出问题  
```cpp
class Solution {
public:

    int atoi(const char *str) {
        int i = 0;
        int len = strlen(str);
        bool positive = true;
        while (str[i] == ' ' && i < len)
            i++;
        if (str[i] == '+')
            i++;
        else if (str[i] == '-') {
            positive = false;
            i++;
        }
        long long sum = 0;
        for (; i < len; i++) {
            if (str[i] < '0' || str[i] > '9')
                break;
            sum = sum * 10 + str[i] - '0';
        }
        sum = positive == true ? sum : -1 * sum;
        int min = 0x80000000;
        int max = 0x7fffffff;
        if (sum < min)
            return 0x80000000;
        else if (sum > max)
            return 0x7fffffff;
        return (int) sum;
    }
};
```

Ex3:[Leetcode:Add Binary](http://oj.leetcode.com/problems/add-binary/)  
记录标记位  
```cpp
//add Binary

class Solution {
public:

    string addBinary(string a, string b) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        string c;
        int flag = 0;
        int lena = a.size();
        int lenb = b.size();
        int len = abs(lena - lenb);
        string append(len, '0');
        if (lena > lenb) {
            b = append + b;
            c.resize(lena, '0');
        } else {
            a = append + a;
            c.resize(lenb, '0');
        }
        for (int j = c.size() - 1; j >= 0; j--) {
            int current = (a[j] - '0') ^(b[j] - '0') ^flag;
            if ((a[j] - '0') +(b[j] - '0') + flag > 1)
                flag = 1;
            else
                flag = 0;
            c[j] = current + '0';
        }
        if (flag == 1)
            c = '1' + c;

        return c;

    }
};
```
Ex4:[Leetcode:Valid Number](oj.leetcode.com/problems/valid-number/)  
复杂的判断条件  
```cpp
class Solution {
public:

    bool isNumber(const char *s) {
        if (s == NULL || s[0] == '\0') return false;
        bool cansign = true;
        bool cane = false;
        bool havee = false;
        bool candot = true;
        bool onlyspace = false;
        bool havenum = false;
        bool numbegin = false;
        while (*s != '\0') {
            char c = *(s++);
            if (c == ' ') {
                if (numbegin)
                    onlyspace = true;
                continue; //skip space
            } else if (onlyspace) {
                return false;
            }
            if (c == '+' || c == '-') {
                if (!cansign) return false;
                cansign = false;
                numbegin = true;
                continue;
            }
            if (c == 'e') {
                if (!cane) return false;
                cane = false;
                havenum = false;
                numbegin = true;
                cansign = true;
                havee = true;
                candot = false;
                continue;
            }
            if (c == '.') {
                if (!candot) return false;
                candot = false;
                numbegin = true;
                cansign = false;
                continue;
            }
            if (c >= '0' && c <= '9') {
                havenum = true;
                numbegin = true;
                cansign = false;
                if (!havee) cane = true;
            } else {
                return false;
            }
        }
        return havenum;
    }
};
```
Ex5:[Leetcode:Pow(x, n)](http://oj.leetcode.com/problems/powx-n/)  
二分法  
```cpp
class Solution {
public:
    double pow(double x, int n) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        if(n == 0) return 1;
        else if(n > 0)
        {
            double half = pow(x, n/2);
            if(n%2 == 0) return half*half;
            else return half*half*x;
        } 
        else
        {
            n = -n;
            double half = pow(x, n/2);
            if(n%2 == 0) return 1.0/(half*half);
            else return 1.0/(half*half*x);
        }
    }
};
```

Ex6:[Leetcode:Sqrt(x)](http://oj.leetcode.com/problems/sqrtx/)  
二分法
```cpp
class Solution {
public:

    int sqrt(int x) {
        int left = 1, right = x / 2;
        int mid;
        int last_mid; // 记录最近一次mid
        if (x < 2) return x;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (x / mid > mid) { // 不要用x > mid * mid，会溢出
                left = mid + 1;
                last_mid = mid;
            } else if (x / mid < mid) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        return last_mid;
    }
};
```
Ex7:[Leetcode:Multiply Strings](http://oj.leetcode.com/problems/multiply-strings/)  
```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
		int len1 = num1.length();
		int len2 = num2.length();
		vector<int> res(len1+len2);
		vector<int> n1;
		vector<int> n2;
		for(int i=num1.length()-1;i>=0;--i)
			n1.push_back(num1[i]-'0');
		for(int i=num2.length()-1;i>=0;--i)
			n2.push_back(num2[i]-'0');
		for(int i=0;i<n1.size();++i){
			for(int j=0;j<n2.size();++j){
				res[i+j] += n1[i]*n2[j];
				res[i+j+1] += res[i+j]/10;
				res[i+j] = res[i+j]%10;
			}
		}
		string ret;
		int i=res.size()-1;
		while(res[i]==0 && i>=0)
			--i;
		if(i<0)
			return "0";
		while(i>=0){
			ret.push_back('0'+res[i]-0);
			--i;
		}
		return ret;
	}
};
```
Ex8:strcpy   
原型声明：char *strcpy(char* dest, const char *src);  
头文件：#include <string.h>  
功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间  
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串，这些都需要调用者来保障。  
返回指向dest的指针。    

一个较好的实现：
```cpp
char* strcpy(char* strDest, const char* strSrc){
    if(strDest == strSrc){
         return strDest;
    }
    assert((strDest != NULL) && (strSrc != NULL));
    char* address = strDest;
    while((*strDest++ = *strSrc++)!='\0');
    return address;
}

```

Ex9:memcpy   
原型声明：void *memcpy(void *dest, const void *src, size_t n);  
头文件：C语言中使用#include <string.h>;  
    C++中使用#include <cstring>和#include <string.h>都可以  
功能：从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中  
说明：  
1.source和destin所指的内存区域可以重叠，但是如果source和destin所指的内存区域重叠,那么这个函数并不能够确保source所在重叠区域在拷贝之前被覆盖。而使用memmove可以用来处理重叠区域。函数返回指向destin的指针.  
2.如果目标数组destin本身已有数据，执行memcpy（）后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。  
注意：source和destin都不一定是数组，任意的可读写的空间均可。  

一个较好的实现：
```cpp
void * memcpy(void * destaddr,void const * srcaddr, size_t len){
     char* dest = destaddr;
     const char * src = srcaddr;
     while(len-- > 0){
          *dest++ = *src++;
     }
     return destaddr; 
}

```

Ex10:memset  
原型声明：void *memset(void *s, int ch, size_t n);  
头文件：<memory.h> or <string.h> memset <wchar.h> wmemset  
功能：将s中前n个字节 （typedef unsigned int size_t）用 ch 替换并返回 s 。  
说明：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。  

一个较好的实现：  
```cpp
void * memset(void *str, int c, size_t count){
     assert(str != NULL);
     void *s = str;
     while(count--){
          *(char*)s = (char) c;
          s = (char*)s + 1;
     }
     return str;
}

```
错误使用示例：  
1.
```cpp
int f(int a[]){
     memset(a,0,sizeof(a));
  }
```
a会退化为指针，导致不能按照预想的方式初始化数组。  

2.
```cpp
int f(){
     int a[5];
     memset(a,1,20);
     for(int i = 0; i < 5; i++){
          cout << a[i] << " ";
     }
  }
```
由于memset是按照字节拷贝，因此a中的每个元素都会被初始化为0x01010101而不是1。  
3.
```cpp
int f(){
     char* s = "12345";
     memset(s,'1',5); 
}
```
运行时错误，因为s指向的是常量区（不可写内存区域），对该区域的写操作会导致程序崩溃。换成char * s = new char[5];或者char s[] = "12345";则没有问题，前者是在堆上的可读写区域，后者是在栈上的可读写区域。  

Ex11:strstr  
原型声明：char *strstr(const char *str1, const char *str2);  
头文件：<string.h>  
功能：该函数返回str2第一次在str1中的位置，如果没有找到，返回NULL  
说明：注意两个参数均是const  

一个较好的实现：  
```cpp
char* strstr(const char* strSrc, const char* str){
     assert(strSrc != NULL && str != NULL);
     const char* s = strSrc;
     const char* t = str;
     for(; *strSrc != '\0'; strSrc++){
          for(s = strSrc, t = str; *t != '\0' && *s == *t; s++, t++){}
          if(*t == '\0') return (char*)strSrc;
     }
     return NULL;
}

```

Ex12:strcmp  
原型声明：unsigned int strlen(const char *str);  
头文件：<string.h>  
功能：返回以'\0'结尾的字符串长度，但不包括'\0'  
说明：注意strlen只能接受char*的参数，不能与sizeof混淆  

一个较好的实现：  
```cpp
unsigned int strlen(const char* str){
     assert(str != NULL);
     const char * eos = str;
     while(*eos++);
     return (unsigned int)(eos-str-1);
}

```

Ex13:strcat  
原型声明：char *strcat(char *dest, const char *src);  
头文件：<string.h>  
功能：把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。  
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串，返回指向dest的指针。  

一个较好的实现：  
```cpp
char* strcat(char* dest, const char* src){
     assert((dest != NULL) && (src != NULL));
     char * ret = dest;
     while(*dest){
          dest++;
     }
     while(*dest++ = *src++){}
     return ret;
}

```
