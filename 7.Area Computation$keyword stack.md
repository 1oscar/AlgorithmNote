##7.Area Computation$keywords stack
###*Area Computation
本章会介绍几个计算给定一维/二维矩阵计算面积问题，类似的问题在[3.Sum$keywords Vector Sum, Tree Sum, Other Sum](3.Sum$keywords Vector Sum, Tree Sum, Other Sum.md)的Other Sum小节也有提到，注意到第三章的问题特点  
1、数值可能为负，也即可能出现部分和为负的情况，此时可以很容易舍弃掉这个部分和，因其对后面的部分和没有贡献；  
2、矩阵中的元素参与运算时并未受到临近元素的条件约束。  
本章提到的问题元素受临近元素的约束，适合用贪心/动态规划求解。开始了。

Ex1:[LeetCode:Container With Most Water](http://oj.leetcode.com/problems/container-with-most-water/)

题意可理解为：给定一个数组，从中选出两个数字，从而使得以两个数字下标之差为宽，以两个数字较小者为高的矩形面积最大。使用两指针贪心法，总是移动数字较小的指针，贪心策略如下：  
*  矩形面积受制于两下标之差，但这个差在两指针靠拢过程中总是缩小的，只能考虑高
*  高是由较小者决定的，如果移动数字较大的，只能使面积变小（因为宽也变小了），而移动较小的则有可能变大

```cpp
class Solution {
public:
    int maxArea(vector<int> &height) {
        if(height.size() == 0 || height.size() == 1) return 0;
        int max = 0, S;
        int low = 0, high = height.size()-1;
        while(low<high){
            if(height[low]<=height[high]){
                S = (high-low)*height[low];
                low++;
            }else{
                S = (high-low)*height[high];
                high--;
            }
            if(S>max) max = S; 
        }
        return max;
    }
};
```

Ex2:[LeetCode:Trapping Rain Water](http://oj.leetcode.com/problems/trapping-rain-water/)

这道题如果从两指针的角度来看会变得非常复杂，要考虑每个区间内的柱高情况。换一个角度，只考虑每个柱子上方的容水量C[i]  
*  `C[i] = Min{LeftHighest[i],RightHighest[i]} - A[i]` 

其中，LeftHighest[i]是柱子i左侧的最高柱高度（不包括自身），RightHighest[i]是柱子i右侧的最高柱高度（不包括自身），A[i]是柱子i的高度。LeftHighest和RightHighest可以用dp求解，最后对C[i]求和即可得到结果。

```cpp
class Solution {
public:
    int trap(int A[], int n) {
        if(n<=2) return 0;
        int units = 0;
        vector<int> leftHighest;
        leftHighest.resize(n);
        leftHighest[0] = 0;
        for(int i = 1; i<=n-1; i++){
            if(A[i-1] < leftHighest[i-1]){
                leftHighest[i] = leftHighest[i-1];
            }else{
                leftHighest[i] = A[i-1];
            }
        }
        
        int rightHighest = 0, tempUnit = 0;
        for(int j = n-2; j>=1; j--){
            if(A[j+1]>rightHighest){
                rightHighest = A[j+1];
            }
            tempUnit = min(leftHighest[j],rightHighest)-A[j];
            if(tempUnit <= 0) continue;
            units += tempUnit;
        }
        return units;
    }
};
```

Ex3:[LeetCode:Largest Rectangle in Histogram](http://oj.leetcode.com/problems/largest-rectangle-in-histogram/)

此题如果用暴力求解同样十分繁琐，以下为O(n)解法，注意到
*  以小矩形A[i]为高的矩形在整个直方图取到的最大面积取决于A[i]右侧的第一个比A[i]小的小矩形A[j]与A[i]形成的宽度
*  如果小矩形A[i]左侧没有比A[i]小的小矩形，则宽度为0到A[j]
*  如果小矩形A[i]右侧没有比A[i]小的小矩形，且左侧也没有（即全局最小），则宽度为直方图的宽度  

这里非常巧妙的运用了stack作为数据结构，用stack维护了以最大递增序列，一旦遇到比栈顶小的小矩形高度则开始计算面积。类似的应用将在Ex4中提及。

**注意**：计算面积时不要使用~~temp = (i - low) * height[low]~~，因为(i - low)并不是以height[low]为高的。举个栗子：  
对于序列1,3,5,4,2的进出栈和运算过程如下：
*  1,3,5顺序入栈
*  4使得5出栈计算面积 temp = (3 - 1 - 1) * 5 = 5 （~~使用错误方式计算为temp = (3 - 2) * 5 = 5，一致~~）
*  4入栈
*  2使得4出栈计算面积 temp = (4 - 1 - 1) * 4 = 8 （~~使用错误方式计算为temp = (4 - 3) * 4 = 4，不一致~~）
*  ...  

显然错误的计算方式会使得计算过程漏掉中间已被出栈的元素形成的宽度，须知这些已出栈的元素高度肯定大于当前元素，是可以与当前元素形成矩形的。

```cpp
    int largestRectangleArea(vector<int> &height) {
        if(height.empty()) return 0;
        stack<int> stk;
        int i = 0, max = 0, temp = 0;
        while(i<=height.size()-1){
            if(stk.empty()||height[i]>height[stk.top()]){//如果递增或者是第一个，入栈
                stk.push(i);
                i++;
            }else{
                int low = stk.top();//出栈
                stk.pop();
                if(stk.empty()){//栈为空说明low的左边都大于height[i]，同时low到i也是大于height[i]的
                    temp = i * height[low];
                }else{
                    temp = (i - stk.top() - 1) * height[low];
                }
                max = max > temp?max:temp;
            }
        }
        while(!stk.empty()){
                int low = stk.top();
                stk.pop();
                if(stk.empty()){
                    temp = height.size() * height[low];
                }else{
                    temp = (height.size() - stk.top() -1) * height[low];
                }
                max = max > temp?max:temp;
        }

        return max;
    }
};
```

Ex4:[Maximal Rectangle](http://oj.leetcode.com/problems/maximal-rectangle/)

这道题有几种解法，但较为巧妙并高效的解法是将其降维至1维，并应用Ex3的算法解决。  
降维举例：  
1 1 1  
1 0 1  
0 1 1  
分别以第1行，第1、2行和第1、2、3行为目标，得到  
1 1 1      ->     1 1 1     ->     应用Ex3算法    

1 1 1  
1 0 1      ->     2 0 2     ->     应用Ex3算法   

1 1 1  
1 0 1  
0 1 1      ->     0 0 3     ->     应用Ex3算法  
故最大面积为3。
```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char> > &matrix) {
        if(matrix.empty()) return 0;
        if(matrix[0].empty()) return 0;
        vector<int> temp(matrix[0].size(), 0);//record histogram value
        stack<int> stk;
        int curIndex = 0, maxArea = 0;
        for(int i = 0; i <= matrix.size()-1; i++){
            for(int k = 0; k <= matrix[0].size()-1; k++){
                if(matrix[i][k] == '1'){
                    temp[k] += 1;
                }else{
                    temp[k] = 0; 
                }
            }
            for(int j = 0; j <= matrix[0].size()-1;){
                if(stk.empty()|| temp[j]>temp[stk.top()]){
                    stk.push(j);
                    j++;
                }else{
                    curIndex = stk.top();
                    stk.pop();
                    int tempArea = 0;
                    if(!stk.empty()){
                        tempArea = (j-stk.top()-1)*temp[curIndex];
                    }else{
                        tempArea = j*temp[curIndex];
                    }
                    maxArea = maxArea>tempArea?maxArea:tempArea;
                }
            }
            while(!stk.empty()){
                    curIndex = stk.top();
                    stk.pop();
                    int tempArea = 0;
                    if(!stk.empty()){
                        tempArea = (temp.size()-stk.top()-1)*temp[curIndex];
                    }else{
                        tempArea = temp.size()*temp[curIndex];
                    }
                    maxArea = maxArea>tempArea?maxArea:tempArea;
            }
        }
        return maxArea;
    }
};
```

Ex5:[Leetcode:Longest Valid Parentheses](http://oj.leetcode.com/problems/longest-valid-parentheses/)

此题虽然不是计算面积类型题，但因其采用的解题思想与Ex3和Ex4十分相似，即使用一个栈来维护历史状态，故而放于此处。

```cpp
class Solution {
public:

    int longestValidParentheses(string s) {
        int max_len = 0, last = -1; // the position of the last ')'
        stack<int> lefts; // keep track of the positions of non-matching '('s
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') {
                lefts.push(i);
            } else {
                if (lefts.empty()) {
                    // no matching left
                    last = i;
                } else {
                    // find a matching pair
                    lefts.pop();
                    if (lefts.empty()) {
                        max_len = max(max_len, i - last);
                    } else {
                        max_len = max(max_len, i - lefts.top());
                    }
                }
            }
        }
        return max_len;
    }
};
