##7.Area Computation$keywords stack
###*Area Computation
本章会介绍几个计算给定一维/二维矩阵计算面积问题，类似的问题在[3.Sum$keywords Vector Sum, Tree Sum, Other Sum](3.Sum$keywords Vector Sum, Tree Sum, Other Sum.md)的Other Sum小节也有提到，注意到第三章的问题特点  
1、数值可能为负，也即可能出现部分和为负的情况，此时可以很容易舍弃掉这个部分和，因其对后面的部分和没有贡献；  
2、矩阵中的元素参与运算时并未受到临近元素的条件约束。  
本章提到的问题元素受临近元素的约束，适合用贪心/动态规划求解。开始了。

Ex1:[LeetCode:Container With Most Water](http://oj.leetcode.com/problems/container-with-most-water/)

题意可理解为：给定一个数组，从中选出两个数字，从而使得以两个数字下标之差为宽，以两个数字较小者为高的矩形面积最大。使用两指针贪心法，总是移动数字较小的指针，贪心策略如下：  
*  矩形面积受制于两下标之差，但这个差在两指针靠拢过程中总是缩小的，只能考虑高
*  高是由较小者决定的，如果移动数字较大的，只能使面积变小（因为宽也变小了），而移动较小的则有可能变大

```cpp
class Solution {
public:
    int maxArea(vector<int> &height) {
        if(height.size() == 0 || height.size() == 1) return 0;
        int max = 0, S;
        int low = 0, high = height.size()-1;
        while(low<high){
            if(height[low]<=height[high]){
                S = (high-low)*height[low];
                low++;
            }else{
                S = (high-low)*height[high];
                high--;
            }
            if(S>max) max = S; 
        }
        return max;
    }
};
```
