###Sliding window$keywords window
  
Ex1:[Leetcode:Longest Valid Parentheses](http://oj.leetcode.com/problems/longest-valid-parentheses/)  
```cpp
class Solution {
public:

    int longestValidParentheses(string s) {
        int max_len = 0, last = -1; // the position of the last ')'
        stack<int> lefts; // keep track of the positions of non-matching '('s
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') {
                lefts.push(i);
            } else {
                if (lefts.empty()) {
                    // no matching left
                    last = i;
                } else {
                    // find a matching pair
                    lefts.pop();
                    if (lefts.empty()) {
                        max_len = max(max_len, i - last);
                    } else {
                        max_len = max(max_len, i - lefts.top());
                    }
                }
            }
        }
        return max_len;
    }
};
```
Ex2:[Leetcode:Longest Substring Without Repeating Characters](http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/)  
```cpp
class Solution {
public:

    int lengthOfLongestSubstring(string s) {
        const int ASCII_MAX = 26;
        int last[ASCII_MAX]; // 记录字符上次出现过的位置
        fill(last, last + ASCII_MAX, -1); // 0 也是有效位置，因此初始化为-1
        int len = 0, max_len = 0;
        for (size_t i = 0; i < s.size(); i++, len++) {
            if (last[s[i] - 'a'] >= 0) {
                max_len = max(len, max_len);
                len = 0;
                i = last[s[i] - 'a'] + 1;
                fill(last, last + ASCII_MAX, -1); // 重新开始
            }
            last[s[i] - 'a'] = i;
        }
        return max(len, max_len); // 别忘了最后一次，例如"abcd"
    }
};
```
Ex3:[Leetcode:Substring with Concatenation of All Words](http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/)  
```java
public class Solution {
    public ArrayList<Integer> findSubstring(String S, String[] L) {
		ArrayList<Integer> list = new ArrayList<Integer>();
		int wordLen = L[0].length();
		int numOfWords = L.length;
		int length = wordLen * numOfWords; // substring length
		if (S.length() < length)
			return list;

		// initialize a hash map to facilitate the word match by word counting
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		for (String word : L) {
			if (!map.containsKey(word)) {
				map.put(word, 1);
			} else {
				map.put(word, map.get(word) + 1);
			}
		}

		for (int i = 0; i <= S.length() - length; i++) {
			String substr = S.substring(i, i + length);
			HashMap<String, Integer> map2 = (HashMap<String, Integer>) map
					.clone();
			// partition the substring into the words of equal length
			while (true) {
				String word = substr.substring(0, wordLen);
				if (map2.containsKey(word)) {
					int num = map2.get(word) - 1;
					// not found: too many occurrences
					if (num < 0) {
						break;
					}
					map2.put(word, num);
					substr = substr.substring(wordLen);
					// found
					if (substr.isEmpty()) {
						list.add(i);
						break;
					}
				}
				// not found: unmatched
				else {
					break;
				}
			}
		}

		return list;
	}
}
```
