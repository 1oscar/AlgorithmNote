#4.Search Array$keywords:search  
##*Search array  
  
Ex1:[Leetcode:single number II](http://oj.leetcode.com/problems/single-number-ii/)[Removed]   
  
两个变量，ones和twos，顺序遍历并且求出异或值，ones表示异或值哪些位 比特1出现一次，twos表示异或值哪些位 比特1出现两次，当异或值的某些位 比特1出现三次的时候，就要对其进行清除，这样就能保证最后得到的ones就是出现一次的数  
```java
public class Solution {
	public int singleNumber(int[] A) {
		int one = 0, two = 0, erase = 0;
		for (int i = 0; i < A.length; i++) {
			two |= one & A[i];
			one ^= A[i];
			erase = ~(one & two);
			two &= erase;
			one &= erase;
		}

		return one;
	}
}
```
另外一个更直观更通用的解法是模拟法，但此种解法在OJ上可能超时。如下：
```cpp
#define ARY 3

int singleNumber(int A[], int n){
	int ret = 0;
	int count[32];
	memset(count,0,sizeof(count));
	for(int i = 0; i <= 31; i++){
		int b = 1 << i;
		for(int j = 0; j <= n-1; j++){
			if(A[j] & b){
				count[i]++;
			}
		}
		if(count[i]%ARY){
			ret |= b;
		}
	}
	return ret;
}
```
在解决复杂同类问题时，这种方法更显得直观，如一组数据中出现两个不同的数字各一次（或k次），其余均出现a次，求出那两个数字，代码如下：
```cpp
int singleNumber(int A[], int n){
	int ret = 0;
	int count[32];
	memset(count,0,sizeof(count));
	for(int i = 0; i <= 31; i++){
		int b = 1 << i;
		for(int j = 0; j <= n-1; j++){
			if(A[j] & b){
				count[i]++;
			}
		}
		if(count[i]%ARY){
			ret |= b;
		}
	}
	return ret;
}

int singleNumberSpecial(int A[], int n){
	int ret = 0;
	int count[32];
	memset(count,0,sizeof(count));
	for(int i = 0; i <= 31; i++){
		int b = 1 << i;
		for(int j = 0; j <= n-1; j++){
			if(A[j] & b){
				count[i]++;
			}
		}
		if(count[i]%ARY == 1){
			ret |= b;
		}
	}
	return ret;
}

vector<int> twoSingleNumber(int A[], int n){
	int twoNum = singleNumberSpecial(A, n);
	int b = twoNum & (-twoNum);
	int B[n],C[n];
	int bi = 0,ci = 0;
	int single1 = 0, single2 = 0;
	for(int i = 0; i <= n-1; i++){
		if(A[i] & b){
			B[bi++] = A[i]; 
		}else{
			C[ci++] = A[i];
		}
	}
	single1 = singleNumber(B, bi);
	single2 = singleNumber(C, ci);
	vector<int> vec;
	vec.push_back(single1);
	vec.push_back(single2);
	return vec;
}
```
singleNumberSpecial()先找到两个数字不同的bit位，然后利用该bit位将数组分成两组，再应用之前的方法求解。

Ex2:[Leetcode:Best Time to Buy and Sell Stock III](http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)  
  
分别记录到i时，0-i的最大利润和i+1到len-1的最大利润，相加即可。  
```java
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) return 0;
        int[] forwardMax = new int[prices.length];
        int[] backwardMax = new int[prices.length];
        
        int buyPoint = prices[0];
        int sellPoint = prices[0];
        int maxProfit = 0;
        forwardMax[0] = 0;
        
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < buyPoint) {
                buyPoint = prices[i];
            }
            forwardMax[i] = Math.max(prices[i] - buyPoint, forwardMax[i - 1]);
        }
        sellPoint = prices[prices.length - 1];
        backwardMax[prices.length - 1] = 0;
        
        for (int i = prices.length - 2; i >= 0; i--) {
            if (prices[i] > sellPoint) {
                sellPoint = prices[i];
            }
            backwardMax[i] = Math.max(sellPoint - prices[i], backwardMax[i + 1]);
        }
        
        int max = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            if (forwardMax[i] + backwardMax[i + 1] > max) {
                max = forwardMax[i] + backwardMax[i + 1];
            }
        }
        if (max < Math.max(forwardMax[prices.length - 1], backwardMax[0])) {
            max = Math.max(forwardMax[prices.length - 1], backwardMax[0]);
        }
        return max;
    }
}
```
  
Ex3:在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。  
  
使用普通的比较时间复杂度是n方。这里介绍一种复杂度为nlogn的方法。该方法要借助归并排序，即将数组分为两部分分别排序，然后merge。之后在对两个子数组进行merge的时候，去比较子数组1的当前元素和子数组2的当前元素，若1大于2，则说明1后面的元素都大于2，所以都为逆序对，将这些数加入结果集。  
```java
public class Main {
    static long count = 0;
 
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            int n = in.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = in.nextInt();
            count = 0;
            mergeSort(a);
            System.out.println(count);
        }
    }
 
    // 将有二个有序数列a[first...mid]和a[mid...last]合并。
    static void mergearray(int a[], int first, int mid, int last, int temp[]) {
        int i = first, j = mid + 1;
        int m = mid, n = last;
        int k = 0;
        while (i <= m && j <= n) {
            if (a[i] > a[j]) {
                // 左数组比右数组大
                temp[k++] = a[j++];
                // 因为如果a[i]此时比右数组的当前元素a[j]大，
                // 那么左数组中a[i]后面的元素就都比a[j]大
                // 【因为数组此时是有序数组】
                count += mid - i + 1;
            } else {
                temp[k++] = a[i++];
            }
        }
        while (i <= m) {
            temp[k++] = a[i++];
        }
        while (j <= n) {
            temp[k++] = a[j++];
        }
        for (i = 0; i < k; i++)
            a[first + i] = temp[i];
    }
 
    static void mergesort(int a[], int first, int last, int temp[]) {
        if (first < last) {
            int mid = (first + last) / 2;
            mergesort(a, first, mid, temp); // 左边有序
            mergesort(a, mid + 1, last, temp); // 右边有序
            mergearray(a, first, mid, last, temp); // 再将二个有序数列合并
        }
    }
 
    static void mergeSort(int a[]) {
        int[] p = new int[a.length];
        mergesort(a, 0, a.length - 1, p);
    }
}
```
  
Ex4:最小的K个数:输入n个整数，找出其中最小的K个数,并按从小到大顺序打印。[Removed]      
  
在这道题中我们利用快速排序的思想，每次都将范围内第一个数作为枢轴，找到前面大于枢轴值的数和后面小于枢轴值的数交换，最后将枢轴值和小于枢轴值的最后一个数交换，完成快速排序。现在数组被分成了两部分，一边小于枢轴值，一边大于枢轴值，等于枢轴值得中间数组下标为t。若k>t，则说明前k个数在后面的子数组里也有，则要对后面排序；若不大于，则不用管后面的子数组  
另：该题也可以用Ex7堆排序实现  
  
```cpp
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
using namespace std;
#define LL long long
void swap(LL *a, LL *b){
    LL tmp=*a;
    *a=*b;
    *b=tmp;
}
 
int partition_arr(int low,int high,LL *arr,const int k){
    if(low>=high)
        return 0;
    LL tmp=arr[low];
    int i=low,j=high+1;
    LL pivot=arr[low];
    while(1){
        while(arr[++i]<pivot);
        while(arr[--j]>pivot);
        if(i<j)
            swap(arr[i],arr[j]);
        else
            break;
         
    }
    swap(arr[low],arr[j]);
    if(low<j-1) partition_arr(low,j-1,arr,k);
    if(j+1<high&&j+1<=k) partition_arr(j+1,high,arr,k);
    return 0;
}
int main()
{
    int n,k,i;
    while(~scanf("%d%d",&n,&k)){
        LL *arr=new LL [n];
        for(i=0;i<n;i++)
            scanf("%lld",&arr[i]);
        partition_arr(0,n-1,arr,k-1);
        if(n>=k){
            printf("%d",arr[0]);
            for(i=1;i<k;i++)
                printf(" %lld",arr[i]);
            printf("\n");
        }
    }
    return 0;
}
```
  
Ex5:任意给定一个正整数N，求一个最小的M（M>1），使得N*M的十进制表示形式里只含有1和0。  
  
首先我们要维护一个余数信息数组，里面存放的是满足表示形式为1和0的，求余N为j的最小的数。若10的i次幂求余N等于j的话，就将这个数加入余数数组。然后遍历已经存在的余数信息数组。假设10的p次幂求余N等于k，则（10的p次幂+10的i次幂）% N =（j+k）%N，所以将余数为k的数和余数为j的数加入余数为（j+k）的数组中。下面是解决这道题的算法，想要看懂该算法需要明白两个条件：（1）（x*10）% N = （x%N*10）% N  （2）在一轮N次更新后，如果余数数组没有出现更新，那么将进入死循环，不再有结果，退出  
```java
import java.util.ArrayList;

public class MyOwn {
	public void Only10(int N) {
		ArrayList<ArrayList<Integer>> b = new ArrayList<ArrayList<Integer>>();
		for (int i = 0; i < N; i++)
			b.add(new ArrayList<Integer>());
		b.get(1).add(0);
		int noUpdate = 0;

		for (int i = 1, j = 10 % N;; i++, j = (j * 10) % N) {
			boolean flag = false;
			if (b.get(j).size() == 0) {
				flag = true;
				b.get(j).add(i);
			}
			for (int k = 1; k < N; k++) {
				if (b.get(k).size() > 0
						&& i > b.get(k).get(b.get(k).size() - 1)
						&& b.get((j + k) % N).size() == 0) {
					flag = true;
					b.set((j + k) % N, b.get(k));
					b.get((j + k) % N).add(i);
				}
			}

			if (flag)
				noUpdate = 0;
			else
				noUpdate++;

			if (noUpdate == N || b.get(0).size() > 0)
				break;
		}

		if (noUpdate == N)
			System.out.println("Not Exit");
		else {
			int max = b.get(0).get(b.get(0).size() - 1);
			long result = 0;
			for (int i = max; i >= 0; i--) {
				if (b.get(0).contains(i))
					result = result * 10 + 1;
				else
					result = result * 10;
			}
			// if (b.get(0).get(0) == 0)
			// result = result * 10;
			System.out.println("result: " + result);
			System.out.println("N: " + N + " M: " + result / N);
		}
	}

	public static void main(String[] args) {
		MyOwn m = new MyOwn();
		m.Only10(24);
	}
}
```
  
Ex6:加强版水王，找出出现次数刚好是一半的数字：有N个数，其中有一个数刚好出现一半次数，要求在线性时间内求出这个数。[Removed]        
首先，水王占总数的一半，说明总数必为偶数；其次，最后一个元素或者是水王，或者不是水王，因此只要在扫描数组的时候每一个元素都与最后一个元素做比较，如果相等则最后一个元素的个数加1，否则不处理。如果最后一个元素的个数为N/2,（N为数组元素个数）则它就是水王，否则水王就是前面N-1个元素中选出的candidate。  
```cpp
int MoreThanHalf(int a[], int N)
{
    int sum1 = 0;//最后一个元素的个数
    int sum2 = 0;
    int candidate;
    int i;
    for(i=0;i<N-1;i++)//扫描前N-1个元素
    {
        if(a == a[N-1])//判断当前元素与最后一个是否相等
        sum1++;
        if(sum2 == 0)
        {
             candidate = a;
             sum2++;
        }
        else
        {
             if(a == candidate)
                 sum2++;
             else
                 sum2--;
        }
     }

     if((sum1+1) == N/2)
         return a[N-1];
     else
         return candidate;
}
```

Ex7:堆排序：写出一个堆排序算法，对数组排序  [Deprecated] 
之所以把堆排序算在搜索里面，是因为很多时候在大数据中查找的时候，会用到堆排序。堆排序的思想就是首先建立一个大根堆，然后将堆顶和数组的最后一个元素交换，之后维护大根堆，然后再交换，如此循环。  
```java
public class MyOwn {
	public void heapSort(int[] a) {
		buildHeap(a);
		for (int i = a.length - 1; i > 0; i--) {
			swap(0, i, a);
			adjust(1, i, a);
		}
	}

	public void swap(int i, int j, int[] a) {
		int tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}

	public void adjust(int i, int max, int[] a) {
		int left = 2 * i;
		int right = 2 * i + 1;
		int big = i;
		if (max >= left && a[left - 1] > a[i - 1])
			big = left;

		if (max >= right && a[right - 1] > a[i - 1])
			big = right;

		if (big != i) {
			swap(i - 1, big - 1, a);
			adjust(big, max, a);
		}
	}

	public void buildHeap(int[] a) {
		int begin = a.length / 2;
		// int begin = (int) (Math.floor(a.length / 2));
		for (int i = begin; i >= 1; i--)
			adjust(i, a.length, a);
	}

	public static void main(String[] args) {
		Solution m = new Solution();
		int[] a = { 32, 1, 9, 5, 7, 12, 0, 4 };
		m.heapSort(a);
		for (int i : a)
			System.out.print(i + " ");
	}
}
```
  
Ex8:[Leetcode:Median of Two Sorted Arrays](http://oj.leetcode.com/problems/median-of-two-sorted-arrays/)  [Removed]
每次A B数组的k/2位置的元素进行比较，舍弃值较小的数所在数组的前k/2个数，如此迭代  
```java
class Solution {
public:

    double findMedianSortedArrays(int A[], int m, int B[], int n) {
        int total = m + n;
        if (total & 0x1)
            return find_kth(A, m, B, n, total / 2 + 1);
        else
            return (find_kth(A, m, B, n, total / 2)
                + find_kth(A, m, B, n, total / 2 + 1)) / 2;
    }
private:

    static double find_kth(int A[], int m, int B[], int n, int k) {
        //always assume that m is equal or smaller than n
        if (m > n) return find_kth(B, n, A, m, k);
        if (m == 0) return B[k - 1];
        if (k == 1) return min(A[0], B[0]);
        //divide k into two parts
        int pa = min(k / 2, m), pb = k - pa;
        if (A[pa - 1] < B[pb - 1])
            return find_kth(A + pa, m - pa, B, n, k - pa);
        else if (A[pa - 1] > B[pb - 1])
            return find_kth(A, m, B + pb, n - pb, k - pb);
        else
            return A[pa - 1];
    }
};
```
