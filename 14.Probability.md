##概率问题

本章收录了一些概率相关问题。

Ex1:已知元素个数n，按顺序等概率的选出m个元素(m<n)，不允许重复
void GenRandom(int n, int m){
     for(int i = 0; i <= n-1; i++){
          if(rand()%(n-i)<m){
               cout << i;
               m--;
          }
     }
}
0被选取的概率：m/n                                                                                                                         
1被选取的概率，分别看0被选中或不被选中的情况：(n-m)/n * m/(n-1) + m/n * (m-1)/(n-1) = m/n
2被选取的概率，分别看0，1是否被选中的情况：(m-2)/(n-2) * m/n * m/n + (m-1)/(n-2) * m/n * (n-m)*2/m + m/(n-2) * (n-m)/n * (n-m)/n = m/n
……
从0~n-1依次计算每个i被输出的概率，发现都是m/n，因此是等概率的随机选取。

Ex2:不知道元素个数n，随机等概率选出k(1<=k<=n)个元素，不允许重复
void pickK(int A[],int n,int k){
     int pick[k];
     for(int i = 0; i <= k-1; i++){
          pick[i] = i+1;     
     }
     int i = k;
     for(; i <= n-1; i++){
          int r = rand(1,i+1);
          if(r >= 1 && r <= k){
               pick[r-1] = i+1;
          }
     }
}
1号结点被选取的概率，遍历到1号结点时被选中，且之后不会被覆盖：k/(k+1) * (k+1)/(k+2) * … * (N-1)/N = K/N
2号结点被选取的概率，遍历到2号结点时被选中，且之后不会被覆盖：k/(k+1) * (k+1)/(k+2) * … * (N-1)/N = K/N
……
k+1号结点被选取的概率，遍历到k+1号结点时被选中，且之后不会被覆盖：k/(k+1) * (k+1)/(k+2) * … * (N-1)/N = K/N
……
最后一个结点被选取的概率，遍历到N号结点时被选中：K/N
从1~N依次计算每个i被最终选取的概率，发现都是K/N。

Ex3:等概率随机排列数组（洗牌算法）
假设有一个数组，包含n个元素。现在要重新排列这些元素，要求每个元素被放到任何一个位置的概率都相等（即1/n），并且直接在数组上重排（in place），不要生成新的数组。用O(n) 时间、O(1)辅助空间。
先想想如果可以开辟另外一块长度为n的辅助空间时该怎么处理，显然只要对n个元素做n次（不放回的）随机抽取就可以了。先从n个元素中任选一个，放入新空间的第一个位置，然后再从剩下的n-1个元素中任选一个，放入第二个位置，依此类推。
按照同样的方法，但这次不开辟新的存储空间。第一次被选中的元素就要放入这个数组的第一个位置，但这个位置原来已经有别的（也可能就是这个）元素了，这时候只要把原来的元素跟被选中的元素互换一下就可以了。很容易就避免了辅助空间

Ex4:利用等概率函数Rand5产生等概率函数Rand3
```cpp
int Rand3(){
     int x;
     do{
          x = Rand5();
     }while(x >= 3);
     return x;//0,2,1
}
```
只要保证返回的3个数是等概率的即可，每个数的概率都为1/5

Ex5:利用等概率函数Rand5产生等概率函数Rand7
```cpp
int Rand7(){
     int x;
     do{
          x = Rand()5*5+Rand5();
     }while(x >= 7);
     return x;
}
```
先生成一个比目标大的概率函数，然后在采用之前的方法即可。在生成较大的目标概率函数时，可以使用RandA()*B+RandB()的形式，可保证不重不漏，且每个数产生的概率相同。
更一般化的：于已知的RandX()函数，可以使用模拟X进制生成一个比目标大的概率函数
如X^3RandX()+X^2RandX()+XRandX()+RandX()可以保证不重不漏,因而能等概率的生成数字

pi=n−1n×n−2n−1×⋯×n−i+1n−i+2×1n−i+1=1n


