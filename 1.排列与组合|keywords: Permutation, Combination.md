##1.排列与组合|keywords: Permutation, Combination
###*Permutation
一般来说有两种解题思路，一种是利用递归生成所有的Permutation，另一种是利用求上一个/下一个Permutation来求出所有的Permutation。该题有可分为有重复和无重复元素的情况。求上一个/下一个的方法适用于有重复和无重复的情况，不需要做适应化修改
而递归方法在有重复元素的情况下需要修改为对当次递归相同的元素做跳过处理。

Ex1:[leetcode:next Permutation](http://oj.leetcode.com/problems/next-permutation/)

高效的方法求下一个Permutation。定义单调递增为最小的序列（如1,2,3,4,5），单调递减为最大的序列（如5,4,3,2,1）。

可以这样理解该方法，想象当前数列形成一个开口向下的折线，折线的左半部分单调递增，折线的右半部分单调递减。对于右半单调递减部分（包含顶点），已经没有办法调换其中的数字使得整体数列变大，因为其本身已经是右半部分子序列的最大情形，因此通过交换左半递增部分和右半递减部分来实现，交换的两数为**折线顶点左侧的第一个数x**和**右半递减部分第一个大于x的数y**，这样保证了产生了比原来更大的序列（因为y>x）。为了完成目标，还需要对原右半递减部分进行升序排序，保证产生了恰比原来大的序列（选用了第一个大于x的y且右半部分经过排序成为右半部分的最小序列）。

这里可以用倒置右半部分代替排序，原因是y是第一个大于x的数，交换这两个数不会打破右半部分的单调递减特性。
```cpp
void nextPermutation(vector<int> &num) {
    for(int i = num.size()-1; i>=1; i--){//改变右起的第一个升序对可以使序列变大
        if(num[i]>num[i-1]){//num[i-1]和num[i]是第一个升序对，此时从i到size()-1是降序
            for(int j = num.size()-1; j>=i; j--){
                if(num[j]>num[i-1]){
                    swap(num[j], num[i-1]);
                    reverse(num.begin()+i,num.end());
                    return;
                }
            }
        }
    }
    reverse(num.begin(),num.end());//说明是降序，直接反转为升序为最小的排列
}
``` 
