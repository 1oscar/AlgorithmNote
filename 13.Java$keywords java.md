##Java
严格的说本章不应收录在本github项目中，但考虑到语言本身对于算法的实现也是有影响，现将一些较为重要和较难记忆理解的Java知识收录此处共查阅学习。
###*与C++的一些不同之处
1.char类型的宽度为16bit；c++为8bit  
2.没有unsigned修饰符；c++有  
3.下列代码是非法的；c++合法  
     int x = 12；  
     {  
          int x = 13;  
     }  
4.String s;并没有创建一个对象，只是声明了一个引用；c++在栈上创建了一个对象   
5.类成员会获得默认值；c++不会自动初始化类成员  
6.类成员可以直接初始化；c++的类成员不能直接初始化，可以在构造函数里初始化  
7.对于对象参数，默认为传引用；c++默认为传值  
8.=号赋值只是使新的引用指向了旧的对象，也即新旧引用指向同一个对象；c++则会生成一个新的对象  
9.>>>号是高位补0右移运算符；c++无此符号  
10.拥有finalize()方法；c++只有析构函数  
11.可以使用int[] A或int A[]方式声明一个数组，因为是引用，不可以指定数组大小；c++只能使用int A[]的方式，可以指定数组大小  
12.默认开启动态绑定；C++使用virtual关键字才能开启动态绑定  

###*Java重要知识点
1.java.lang是默认导入每个java文件的  
2.equals()默认行为是比较引用，可以重写；==判断的是引用的内存地址是否相同  
3.对byte和short的位移操作要特别小心，它们会被转换为int型然后位移，这会导致不正确的结果  
4.bool类型不允许任何类型转换，也不允许使用类似while(1)的语句，0,1并不等同于false和true，必须使用while(true)  
5.float或double转为整形值时，总是对该数字进行截尾  
6.提升：对基本数据类型进行算术运算或按位运算时，低于int型的数据类型（char、byte和short）总是会先转换为int再运算；数据类型大的类型决定了结果的类型  
7.不能仅仅使用返回值不同的方法作为重载方法，应该使参数列表不同（至少是顺序不同）  
8.如果已经定义了一个构造器，无论是否有参数，编译器不会自动创建默认构造器  
9.this的三个应用场合：  
  *用于引用自身对象的成员，特别是因为成员与方法参数重名  
  *用于在一个重载的构造器中调用另一个构造器，此时必须放在第一句，且只有构造器可以调用其他构造器   
  *用于返回自身对象的引用  
10.被static修饰的方法内不能调用非static方法和成员，因为非static方法和成员依赖具体的对象（除非这个静态方法获得自身类的一个对象实例并通过该实例调用非晶态方法）  
11.Java没有C++的析构函数，取而代之是finalize()，用于释放非Java代码（如native C）申请的系统资源，由GC调用（不要直接调用finalize()方法），而GC的调用时机是不能被预期的。  
12.Java的GC机制包括两种："停止-复制"和“标记-清扫”，都是从堆栈和静态存储区开始扫描引用。采用自适应技术在两种技术中切换，碎片多时用“停止-复制”，碎片少时用“标记-清扫”。  
13.不同于类成员，局部变量必须被初始化，否则报错。  
14.类成员的初始化顺序:类加载->new操作（或访问静态域，此行为不会导致空间分配）->静态成员初始化（包括静态块）(只发生一次，如果以前new操作/访问静态域操作出现过则不再初始化)->分配空间，非静态成员初始化（包括非静态块）->构造方法。类成员变量的初始化（包括但不限于默认初始化行为）绝对先于构造器的对类成员的初始化操作。  
   一个继承自A类的B类对象的初始化顺序：类B加载->类A加载->类A的静态成员初始化->类B的静态成员初始化->类A非静态成员初始化->类A的构造方法->类B非静态成员初始化->类B的构造方法  
15.构造器是static方法。  
16.一下两种声明和初始化数组的方式都是合法的，最后一个逗号是可选的  
     *Integer[] a = {new Integer(1), new Integer(2), 3, }//Auto Boxing  
     *Integer[] b = new Integer[]{new Integer(1), new Integer(2), 3, }//Auto Boxing  
17.可变参数形如void function(type... args)，三个注意点：  
     *可以给可变参数列表传0个参数  
     *可变参数列表不依赖于Auto Boxing  
     *尽量避免在多个重载方法中使用可变参数，可能会引起歧义  
          void function(int a, int... args){}  
          void function(int... args){}  
     *如果必须使用，添加非可变参数如  
          void function(int a, int... args){}  
          void function(string b, int... args){}  
18.enum的使用跟类相近，可以使用在switch内。可以对一个enum对象赋予枚举类型值，如EnumType et = EnumType.type1  
19.一个Java源文件中最多只能有一个public类，当有一个public类时，源文件名必须与之一致，否则无法编译，如果源文件中没有一个public类，则文件名与类中没有一致性要求。至于main()不是必须要放在public类中才能运行程序。总结出如下4点  
     *Java源文件可以有public类，也可以没有  
     *如果有public类，则该public类必须与文件名同名  
     *如果没有public类，则不要求有与文件名同名的类  
     *main()方法的放在哪个类里没有硬性要求，跟是否在public类中也没有关系，一个文件中多个类可以各自持有一个main()方法，都可以用java命令运行  
20.Java解释器的运行过程是首先找出环境变量CLASSPATH用于查找.class的根目录，然后加载。  
21.访问权限控制的等级：public->protected->包访问权限->private  
22.类的权限控制的等级：public->包访问权限，不可以是protected或private的  
23.一个类的构造器是private的，任何其他类无法直接创建该类，只有该类的static方法或对static对象赋值（即非延迟化实现）才可以创建一个该类的对象  
24.使用成员的访问控制主要有两个原因：  
     *使用户不要碰触他们不该碰触的部分  
     *更重要的是，可以让类的设计者改变类的内部实现而不影响会对客户端程序员产生重大影响  
25.使用super可以访问从基类继承的方法和成员，前提是这些方法和成员是public、protected，或着父类和子类在同一个包内且不是private的。  
26.如果父类的构造器没有无参形式（由于用户自定义了带参构造器），子类的构造器需要手动调用super(para);如果存在，则自动调用super();  
27.如果需要保证一个行为一定被执行（例如一些清除操作，手动编写和调用而不应该依赖finalize()和GC），应该将该行为放在finally块中：  
     try{  
          ...  
     }finally{  
          //mustBeDone();  
     }  
     对于清除操作，如果被清除对象是派生类，则注意对其父类也调用清除操作，方式类似构造方法的构造链的，顺序相反，与C++的析构函数的方式相同。  
28.可以把 @ override放在重写方法之前，如果对父类的方法进行的重载而非重写，编译器会报错  
29.final关键字使用在数据、方法和类的意义不同。  
     *final数据：  
          +对于基本类型，final使数值恒定不变；对于对象引用，final使对象引用不变，而对象本身是可以改变的  
               -如数组对象，final int[] a = {1,2,3}，a只能指向该数组，但1,2,3是可以修改的  
          +static final标识的变量是编译期常量  
               -如 final static int a = 1;  
          +final数据的两次初始化机会：定义处和构造器中。如果在定义处没有初始化，在构造器中必须初始化  
          +final参数：在方法内不允许修改该参数变量的值  
     *final方法：  
          +禁止该方法被重写，但可以使用，也即关闭动态绑定  
          +在子类中声明一个跟父类private（final）方法同样的方法并不会产生重写效果  
          +private方法都隐式的被指定为final方法，private方法并不作为父类接口的一部分，向上转型不能调用子类的同名方法（非覆盖），可能可以调用自身的private方法（如果在父类内部）  
     *final类：该类不能被继承  
30.多态的三种例外情况：  
     *private方法。如上所述，private方法被隐式的指定为final方法，因此也不存在重写的情况  
     *域。同名的静态域被当成两个不同的数据空间，而不能进行“多态”，根据引用决定调用的目标  
     *静态方法。与静态域类似，同名的静态方法会被当成两个不同的方法，没有“多态”，根据引用决定调用的目标  
31.在构造器里调用多态方法可能导致使用了未被正确初始化的变量，如在父类的构造器调用一个在子类中重写的方法，而该方法可能使用了一个子类中的非静态成员变量，该变量此时还未被正确赋值。  
32.Java SE5中添加了协变返回类型，这种机制允许子类重写方法返回父类被重写方法返回类型的派生类型，这样的形式同样被认为是多态的。  
33.包含abstract方法的类必是抽象类，抽象类不一定包含abstract方法（可能出于阻止产生该类对象的目的）  
34.Interface的域默认的是static、final和public，方法默认为public。在实现Interface时，必须将实现接口的方法声明为public。接口也可以通过extends关键字来扩展接口  
35.使用Interface的理由  
     *为实现多继承提供类似的实现，进而能够向上转型为多个基类型（以及由此带来的灵活性）  
     *空接口提供一个标签机制  
     *多个不同的类型实现同一个接口，可以使得这些类能够向上转型为同一个基类型（例如作为方法的参数来实现策略设计模式，或是作为泛型容器的实现方式）  
36.菱形继承问题：在Java中只有一个不合法的情况，即在一个类实现的两个接口中使用了完全一致的静态变量。使用同名函数能够正常工作。  
37.非静态内部类的创建需要捕获一个指向外围类的对象引用，因此不能脱离外围类对象创建内部类对象。内部类对象能访问器外围对象的所有成员，而且不需要任何特殊条件（即使为private），且嵌套层数不影响其对外围对象成员的访问，此外，内部类还拥有器外围类的所有元素的访问权。  
38.创建非静态内部类的两种方法：  
     *Outer out = new Outer();  
      Outer.Inner in = out.createInner();  
     *Outer out = new Outer();  
      Outer.Inner in = out.new Inner();  
     不能是Outer.Inner in = new Inner();或者Outer.Inner in = out.new Outer.Inner();
39.静态内部类（嵌套类）不需要对外部类对象的引用  
40.匿名内部类没有构造器，但可以使用非静态块达到实例初始化的目的。如果想在匿名内部类中使用外部方法的变量/参数，则要求这些变量/参数是final的。（传给基类构造器的使用不在此列）  
41.匿名内部类只能实现一个接口或者继承一个基类（2选1）  
42.为什么需要内部类：  
