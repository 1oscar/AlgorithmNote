##Tricky Problems
本章用于收录一些微妙、技巧性较强的问题。一般的，问题所属分类模糊或同类问题较少会导致该问题被收录在Tricky Problems，在条件成熟的情况下可以被移出至新的章节。

Ex1:[N-Queens II](http://oj.leetcode.com/problems/n-queens-ii/)

八皇后是递归和回溯的经典问题，递归解法思路比较简明：每次递归选择处在新一行、未被使用列的点，且保证该点与已选择的点斜率绝对值不为1，使用一个Vector来记录已选择的棋子所在列即可，这种做法是有效且正确的。  
这里介绍求N-queens可行解个数最快的算法。代码如下，思路见注释：
```cpp
class Solution {
public:
    int result, upperLim;
    int totalNQueens(int n) {
        if(n <= 0) return 0;
        result = 0;
        upperLim = (1 << n) - 1;//掩码，用于过滤掉高于n位的无用bits
        recursion(0, 0, 0);//递归初始条件(0x00000000,0x00000000,0x00000000)
        return result;
    }
    
    int recursion(int colInfo, int leftDiagonal, int rightDiagonal){
        //3个参数均表示禁位，即之前所选节点对于本次递归所在行选择的限制，来自3方面
        //colInfo表示列禁位，leftDiagonal表示左斜线禁位，rightDiagonal表示右斜线禁位
        //如colInfo == 0x00000003表示最后两列已被选择，不可再次选择
        //leftDiagonal == 0x00000001表示前面选择的点使得本次递归所在行不能选择最后一列
        int pos, p;
        //pos表示本次递归所在行可用位置，如0x00000003表示最右两列可用
        //p表示从pos中取出的、只包含“最靠右”的1的数
        if(colInfo == upperLim){
            result++;//所有列已被选择，产生一个可行解
        }else{
            pos = upperLim & ~(colInfo | leftDiagonal | rightDiagonal);
            //三个输入参数的或操作是对列、左斜线和右斜线禁位效果合成，取反则是得到可用位
            //与掩码操作过滤掉高于n位的无用bits
            while(pos){//不为0表示还有可用位置
                p = pos & -pos;//取出“最靠右”1操作
                pos = pos - p;//消除已选的1
                recursion(colInfo | p, (leftDiagonal | p) << 1, (rightDiagonal | p) >> 1);
                //对p的或操作表示该位已选择，对下一层递归起到禁位效果
                //位移的起到表示斜线禁位的效果，举例如下
                //位移前:leftDiagonal == 0001000(7bits), rightDiagonal == 0001000(7bits)
                //位移后:leftDiagonal == 0010000(7bits), rightDiagonal == 0000100(7bits)
                //显然本次选中第四列会对下一层递归起到第3和第5列禁位效果
            }
        }
    }
};
```
Ex2:[leetcode:Gray Code](http://oj.leetcode.com/problems/gray-code/)  
一个普通解法:
```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> result;
        result.push_back(0);
        if(n <= 0) return result;
        int multiplier = 1;
        for(int i = 0;i<n;i++){
            for(int j = (1<<i)-1;j>=0;j--){
                result.push_back(result.at(j)+multiplier);
            }
            multiplier <<= 1;
        }
        return result;
    }
};
```
技巧性较强的解法，二进制转格雷码：gray = (binary) xor (binary >> 1)  
```cpp
class Solution {
public:

    vector<int> grayCode(int n) {
        vector<int> vec;
        int size = 1 << n;
        for (int i = 0; i < size; i++) {
            vec.push_back(i^(i >> 1));
        }
        return vec;
    }
};
```

Ex3:[Leetcode:Evaluate Reverse Polish Notation](http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/)  
一个栈保存操作数，当遇到操作符时，弹出两个操作数，计算完后将结果压入栈  
```java 
public class Solution {
    public int evalRPN(String[] tokens) {
 
        int returnValue = 0;
 
        String operators = "+-*/";
 
        Stack<String> stack = new Stack<String>();
 
        for(String t : tokens){
            if(!operators.contains(t)){
                stack.push(t);
            }else{
                int a = Integer.valueOf(stack.pop());
                int b = Integer.valueOf(stack.pop());
                int index = operators.indexOf(t);
                switch(index){
                    case 0:
                        stack.push(String.valueOf(a+b));
                        break;
                    case 1:
                        stack.push(String.valueOf(b-a));
                        break;
                    case 2:
                        stack.push(String.valueOf(a*b));
                        break;
                    case 3:
                        stack.push(String.valueOf(b/a));
                        break;
                }
            }
        }
 
        returnValue = Integer.valueOf(stack.pop());
 
        return returnValue;
 
    }
}
```
Ex4:[Leetcode:Decode Ways](http://oj.leetcode.com/problems/decode-ways/)  
每次遍历时，pre表示上上次解码方法总数，cur表示上次解码总数。假设当前解码方法数为sum，每次遍历初始化sum为0，若当前字符可以被单独解码，sun+=cur，否则sum+=0；若当前字符和上一个字符可以共同解码，sum+=pre，否则sum+=0。计算完之后，pre=cur，cur=sum  
```cpp
class Solution {
public:

    int numDecodings(const string &s) {
        if (s.empty() || s[0] == '0') return 0;
        int prev = 0;
        int cur = 1;
        // 长度为n 的字符串，有n+1 个阶梯
        for (size_t i = 1; i <= s.size(); ++i) {
            if (s[i - 1] == '0') cur = 0;
            if (i < 2 || !(s[i - 2] == '1' ||
                    (s[i - 2] == '2' && s[i - 1] <= '6')))
                prev = 0;
            int tmp = cur;
            cur = prev + cur;
            prev = tmp;
        }
        return cur;
    }
};
```

Ex5:[Leetcode:Max Points on a Line](http://oj.leetcode.com/problems/max-points-on-a-line/)  
对于i j两个点，看点k是否在ij确定的直线上。有两种情况：1）该直线的斜率无法求出，则判断ijk三点横坐标是否相同；2）三点中任意两点直线斜率相同。避免重复计算：遍历点k时，先计算出后面需要用到的几个数。
```cpp
class Solution {
public:

    int maxPoints(vector<Point> &points) {
        if (points.size() == 0)
            return 0;
        if (points.size() == 1)
            return 1;
        int result = 0;
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                bool flag = false;
                int cnt = 0;
                int a, b, c, d;
                if (points[i].x == points[j].x)
                    flag = true;
                else {
                    a = points[j].x * points[i].y;
                    b = points[i].x * points[j].y;
                    c = points[j].x - points[i].x;
                    d = points[j].y - points[i].y;
                }
                for (int k = 0; k < points.size(); k++) {
                    if (flag && points[k].x == points[i].x)
                        cnt++;
                    if (!flag && (a + d * points[k].x == b + c * points[k].y))
                        cnt++;
                }
                result = max(result, cnt);
            }
        }
        return result;
    }
};
```

Ex6:Outer Points of Rectangles  
给定输入为vector<Rectangle>，其中Rectangle的成员需要包括int x1,int x2和int y，也即在x-y坐标系中，所有Rectangles的底边都在x轴上，因此依靠这3个int值即可唯一确定Rectangle。现要求所有Rectangles组成的图形的外围点集。  
例如，对于输入：    
Rectangle 1:(-4,2,2)  
Rectangle 2:(-3,1,1)  
Rectangle 3:(-3,-1,3)  
Rectangle 4:(0,2,2)  
Rectangle 5:(2,4,1)  
输出点集：  
(-4,0),(-3,2),(-3,3),(-1,3),(-1,1),(0,1),(0,2),(2,2),(2,1),(4,1),(4,0)  
//TODO：解法解析
代码如下：
```cpp
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

class Rectangle{
public:
	int x1;
	int x2;
	int y;
	Rectangle(int _x1, int _x2, int _y){
		x1 = _x1;
		x2 = _x2;
		y = _y;	
	}
	
	bool operator == (const Rectangle & r) const{
		if(x1 == r.x1 && x2 == r.x2 && y == r.y){
			return true;
		}else{
			return false;
		}
	}
	
	bool operator < (const Rectangle & r) const{
		if(y > r.y){//descending
			return true;
		}else{
			return false;
		}
	}
};

class Point{
public:
	int x;
	int y;
	int id;//1 or 2
	Rectangle * rec;
	Point(int _x, int _y, int _id,Rectangle* _rec){
		x = _x;
		y = _y;
		id = _id;
		rec = _rec;
	}
};

bool cmp(const Point* p1, const Point* p2){
	if(p1->x < p2->x || (p1->x == p2->x && p1->y < p2->y)){
		return true;
	}else{
		return false;
	}
}

int main(){	
	vector<Rectangle*> inputVec;
	inputVec.push_back(new Rectangle(-4,-2,2));
	inputVec.push_back(new Rectangle(-3,1,1));
	inputVec.push_back(new Rectangle(-3,-1,3));
	inputVec.push_back(new Rectangle(0,2,2));
	inputVec.push_back(new Rectangle(2,4,1));
	
	vector<Point*> pointVec;
	for(int i = 0; i <= (int)(inputVec.size()-1); i++){
		pointVec.push_back(new Point(inputVec[i]->x1,inputVec[i]->y,1,inputVec[i]));
		pointVec.push_back(new Point(inputVec[i]->x2,inputVec[i]->y,2,inputVec[i]));
	}
	
	//sort points
	sort(pointVec.begin(),pointVec.end(),cmp);
	
	set<Rectangle> recSet; // RBT
	recSet.clear();
	
	vector<Point*> ret;// answer
	ret.clear();
	
	int currentMaxHeight = 0;//current Highest
	
	for(int i = 0; i <= (int)(pointVec.size()-1); i++){
		if(pointVec[i]->id == 1){
			if(pointVec[i]->y > currentMaxHeight){
				ret.push_back(new Point(pointVec[i]->x,currentMaxHeight,0,NULL));
				ret.push_back(pointVec[i]);
			}else if(pointVec[i]->y == currentMaxHeight){
				ret.push_back(pointVec[i]);
			}
			recSet.insert(*(pointVec[i]->rec));
			currentMaxHeight = (*(recSet.begin())).y;//update
		}else if(pointVec[i]->id == 2){
			set<Rectangle>::iterator itr = recSet.find(*(pointVec[i]->rec));
			if(itr != recSet.end()){
				recSet.erase(itr);
			}
			if(recSet.empty()){
				currentMaxHeight = 0;
			}else{
				currentMaxHeight = (*(recSet.begin())).y;//update
			}
			
			if(pointVec[i]->y > currentMaxHeight){
				ret.push_back(pointVec[i]);
				ret.push_back(new Point(pointVec[i]->x,currentMaxHeight,0,NULL));
			}else if(pointVec[i]->y == currentMaxHeight){
				ret.push_back(pointVec[i]);
			}
		}
	}
	
	//output
	for(int i = 0; i <= (int)(ret.size()-1); i++){
		cout << "[" << ret[i]->x << "," << ret[i]->y << "]" << endl;
	}
}
```

