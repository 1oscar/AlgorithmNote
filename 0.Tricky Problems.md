##Tricky Problems
本章用于收录一些微妙、技巧性较强的问题。一般的，问题所属分类模糊或同类问题较少会导致该问题被收录在Tricky Problems，在条件成熟的情况下可以被移出至新的章节。

Ex1:[N-Queens II](http://oj.leetcode.com/problems/n-queens-ii/)

八皇后是递归和回溯的经典问题，递归解法思路比较简明：每次递归选择处在新一行、未被使用列的点，且保证该点与已选择的点斜率绝对值不为1，使用一个Vector来记录已选择的棋子所在列即可，这种做法是有效且正确的。  
这里介绍求N-queens可行解个数最快的算法。代码如下，思路见注释：
```cpp
class Solution {
public:
    int result, upperLim;
    int totalNQueens(int n) {
        if(n <= 0) return 0;
        result = 0;
        upperLim = (1 << n) - 1;//掩码，用于过滤掉高于n位的无用bits
        recursion(0, 0, 0);//递归初始条件(0x00000000,0x00000000,0x00000000)
        return result;
    }
    
    int recursion(int colInfo, int leftDiagonal, int rightDiagonal){
        //3个参数均表示禁位，即之前所选节点对于本次递归所在行选择的限制，来自3方面
        //colInfo表示列禁位，leftDiagonal表示左斜线禁位，rightDiagonal表示右斜线禁位
        //如colInfo == 0x00000003表示最后两列已被选择，不可再次选择
        //leftDiagonal == 0x00000001表示前面选择的点使得本次递归所在行不能选择最后一列
        int pos, p;
        //pos表示本次递归所在行可用位置，如0x00000003表示最右两列可用
        //p表示从pos中取出的、只包含“最靠右”的1的数
        if(colInfo == upperLim){
            result++;//所有列已被选择，产生一个可行解
        }else{
            pos = upperLim & ~(colInfo | leftDiagonal | rightDiagonal);
            //三个输入参数的或操作是对列、左斜线和右斜线禁位效果合成，取反则是得到可用位
            //与掩码操作过滤掉高于n位的无用bits
            while(pos){//不为0表示还有可用位置
                p = pos & -pos;//取出“最靠右”1操作
                pos = pos - p;//消除已选的1
                recursion(colInfo | p, (leftDiagonal | p) << 1, (rightDiagonal | p) >> 1);
                //对p的或操作表示该位已选择，对下一层递归起到禁位效果
                //位移的起到表示斜线禁位的效果，举例如下
                //位移前:leftDiagonal == 0001000(7bits), rightDiagonal == 0001000(7bits)
                //位移后:leftDiagonal == 0010000(7bits), rightDiagonal == 0000100(7bits)
                //显然本次选中第四列会对下一层递归起到第3和第5列禁位效果
            }
        }
    }
};
```
Ex2:[leetcode:Gray Code](http://oj.leetcode.com/problems/gray-code/)  
二进制转格雷码：gray = (binary) xor (binary >> 1)  
```cpp
class Solution {
public:

    vector<int> grayCode(int n) {
        vector<int> vec;
        int size = 1 << n;
        for (int i = 0; i < size; i++) {
            vec.push_back(i^(i >> 1));
        }
        return vec;
    }
};
```

Ex3:[Leetcode:Regular Expression Matching](http://oj.leetcode.com/problems/regular-expression-matching/)  
```cpp
class Solution {
public:

    bool isMatch(const char *s, const char *p) {
        if (*p == '\0') return *s == '\0';
        // next char is not '*', then must match current character
        if (*(p + 1) != '*') {
            if (*p == *s || (*p == '.' && *s != '\0'))
                return isMatch(s + 1, p + 1);
            else
                return false;
        } else { // next char is '*'
            while (*p == *s || (*p == '.' && *s != '\0')) {
                if (isMatch(s, p + 2))
                    return true;
                s++;
            }
            return isMatch(s, p + 2);
        }
    }
};
```

Ex4:[Leetcode:Simplify Path](http://oj.leetcode.com/problems/simplify-path/)  
```cpp
class Solution {
public:

    string simplifyPath(string path) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        vector<string> pathes;
        string seg = "";
        for (int i = 0; i <= path.size(); ++i) {
            if (i == path.size() || path[i] == '/') {
                if (seg == "..") {
                    if (pathes.size() > 0) {
                        pathes.pop_back();
                    } else {
                        //return "/";//error, in the test set, this case just ignore
                    }
                } else if (seg == ".") {
                    //do nothing
                } else if (seg.size() > 0) {
                    pathes.push_back(seg);
                }
                seg = "";
            } else {
                seg += path[i];
            }
        }
        string ret = "/";
        for (int i = 0; i < pathes.size(); ++i) {
            if (i > 0) ret += "/";
            ret += pathes[i];
        }
        return ret;
    }
};
```

Ex5:[Leetcode:Evaluate Reverse Polish Notation](http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/)  
```java 
public class Solution {
    public int evalRPN(String[] tokens) {
 
        int returnValue = 0;
 
        String operators = "+-*/";
 
        Stack<String> stack = new Stack<String>();
 
        for(String t : tokens){
            if(!operators.contains(t)){
                stack.push(t);
            }else{
                int a = Integer.valueOf(stack.pop());
                int b = Integer.valueOf(stack.pop());
                int index = operators.indexOf(t);
                switch(index){
                    case 0:
                        stack.push(String.valueOf(a+b));
                        break;
                    case 1:
                        stack.push(String.valueOf(b-a));
                        break;
                    case 2:
                        stack.push(String.valueOf(a*b));
                        break;
                    case 3:
                        stack.push(String.valueOf(b/a));
                        break;
                }
            }
        }
 
        returnValue = Integer.valueOf(stack.pop());
 
        return returnValue;
 
    }
}
```
Ex6:[Leetcode:Decode Ways](http://oj.leetcode.com/problems/decode-ways/)  
```cpp
class Solution {
public:

    int numDecodings(const string &s) {
        if (s.empty() || s[0] == '0') return 0;
        int prev = 0;
        int cur = 1;
        // 长度为n 的字符串，有n+1 个阶梯
        for (size_t i = 1; i <= s.size(); ++i) {
            if (s[i - 1] == '0') cur = 0;
            if (i < 2 || !(s[i - 2] == '1' ||
                    (s[i - 2] == '2' && s[i - 1] <= '6')))
                prev = 0;
            int tmp = cur;
            cur = prev + cur;
            prev = tmp;
        }
        return cur;
    }
};
```

Ex7:[Leetcode:Text Justification](http://oj.leetcode.com/problems/text-justification/)  
```java
public class Solution {
    public ArrayList<String> fullJustify(String[] words, int L) {
        // Start typing your Java solution below
        // DO NOT write main() function
        ArrayList<String> result = new ArrayList<String>();
        String[] spaces = new String[L+1];
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < L+1; i++) {
            spaces[i] = builder.toString();
            builder.append(' ');
        }
         
        int len = words.length;
         
        int i = 0;
         while (i < len) {
             int j = i;
             int total = words[i].length();
             while (true) { 
                 j++;
                 if (j == len) break;
                 int w = words[j].length();
                 if (total + w + 1 > L) break;
                 total += w + 1;                
             }
             int left = L - total;
             int c = j - i;
             if (c == 1) { // single word
                 StringBuilder sb = new StringBuilder(words[i]);
                 sb.append(spaces[left]);
                 result.add(sb.toString());
             }
             else { // multi-word
                 if (j == len) { // last line
                     StringBuilder sb = new StringBuilder(words[i]);
                     for (int x = i+1; x < j; x++) {
                         sb.append(' ');
                         sb.append(words[x]);
                     }
                     sb.append(spaces[left]);
                     result.add(sb.toString());
                 }
                 else {
                     int k = left / (c - 1); // extra ' ' for every gap
                     int l = left - k * (c - 1); // count for first gaps with extra '' 
                     StringBuilder sb = new StringBuilder(words[i]);
                     for (int x = i+1; x < j; x++) {
                         if (l > 0) {
                             sb.append(' ');
                             l--;
                         }
                         sb.append(' ');
                         sb.append(spaces[k]);
                         sb.append(words[x]);
                     }
                     result.add(sb.toString());
                 }
             }
             i = j;
         }        
         return result; 
    }
}
```
Ex8:[Leetcode:Max Points on a Line](http://oj.leetcode.com/problems/max-points-on-a-line/)  
```cpp
class Solution {
public:

    int maxPoints(vector<Point> &points) {
        if (points.size() == 0)
            return 0;
        if (points.size() == 1)
            return 1;
        int result = 0;
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                bool flag = false;
                int cnt = 0;
                int a, b, c, d;
                if (points[i].x == points[j].x)
                    flag = true;
                else {
                    a = points[j].x * points[i].y;
                    b = points[i].x * points[j].y;
                    c = points[j].x - points[i].x;
                    d = points[j].y - points[i].y;
                }
                for (int k = 0; k < points.size(); k++) {
                    if (flag && points[k].x == points[i].x)
                        cnt++;
                    if (!flag && (a + d * points[k].x == b + c * points[k].y))
                        cnt++;
                }
                result = max(result, cnt);
            }
        }
        return result;
    }
};
```
