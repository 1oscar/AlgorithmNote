##Tricky Problems
本章用于收录一些微妙、技巧性较强的问题。一般的，问题所属分类模糊或同类问题较少会导致该问题被收录在Tricky Problems，在条件成熟的情况下可以被移出至新的章节。

Ex1:[N-Queens II](http://oj.leetcode.com/problems/n-queens-ii/)

八皇后是递归和回溯的经典问题，递归解法思路比较简明：每次递归选择处在新一行、未被使用列的点，且保证该点与已选择的点斜率绝对值不为1，使用一个Vector来记录已选择的棋子所在列即可，这种做法是有效且正确的。  
这里介绍求N-queens可行解个数最快的算法。代码如下，思路见注释：
```cpp
class Solution {
public:
    int result, upperLim;
    int totalNQueens(int n) {
        if(n <= 0) return 0;
        result = 0;
        upperLim = (1 << n) - 1;//掩码，用于过滤掉高于n位的无用bits
        recursion(0, 0, 0);//递归初始条件(0x00000000,0x00000000,0x00000000)
        return result;
    }
    
    int recursion(int colInfo, int leftDiagonal, int rightDiagonal){
        //3个参数均表示禁位，即之前所选节点对于本次递归所在行选择的限制，来自3方面
        //colInfo表示列禁位，leftDiagonal表示左斜线禁位，rightDiagonal表示右斜线禁位
        //如colInfo == 0x00000003表示最后两列已被选择，不可再次选择
        //leftDiagonal == 0x00000001表示前面选择的点使得本次递归所在行不能选择最后一列
        int pos, p;
        //pos表示本次递归所在行可用位置，如0x00000003表示最右两列可用
        //p表示从pos中取出的、只包含“最靠右”的1的数
        if(colInfo == upperLim){
            result++;//所有列已被选择，产生一个可行解
        }else{
            pos = upperLim & ~(colInfo | leftDiagonal | rightDiagonal);
            //三个输入参数的或操作是对列、左斜线和右斜线禁位效果合成，取反则是得到可用位
            //与掩码操作过滤掉高于n位的无用bits
            while(pos){//不为0表示还有可用位置
                p = pos & -pos;//取出“最靠右”1操作
                pos = pos - p;//消除已选的1
                recursion(colInfo | p, (leftDiagonal | p) << 1, (rightDiagonal | p) >> 1);
                //对p的或操作表示该位已选择，对下一层递归起到禁位效果
                //位移的起到表示斜线禁位的效果，举例如下
                //位移前:leftDiagonal == 0001000(7bits), rightDiagonal == 0001000(7bits)
                //位移后:leftDiagonal == 0010000(7bits), rightDiagonal == 0000100(7bits)
                //显然本次选中第四列会对下一层递归起到第3和第5列禁位效果
            }
        }
    }
};
```
Ex2:[leetcode:Gray Code](http://oj.leetcode.com/problems/gray-code/)  
二进制转格雷码：gray = (binary) xor (binary >> 1)  
```cpp
class Solution {
public:

    vector<int> grayCode(int n) {
        vector<int> vec;
        int size = 1 << n;
        for (int i = 0; i < size; i++) {
            vec.push_back(i^(i >> 1));
        }
        return vec;
    }
};
```

Ex3:[Leetcode:Regular Expression Matching](http://oj.leetcode.com/problems/regular-expression-matching/)  
每次首先判断p当前字符的下一个字符是不是*  
* 不是\*，如果s和p的当前字符相同，判断s和p的下一位
* 是\*，若p的当前字符是'.'，则可以匹配到s的末尾；否则，用p的当前字符一直去匹配s，若p当前字符等于s当前字符，判断若p重复0次s和p是否能匹配；若能则跳出循环，若不能，用p当前字符继续匹配s的下一位。当p的当前字符终于和s的当前字符不相等时，则返回p后面的字符串和s是否匹配  
```cpp
class Solution {
public:

    bool isMatch(const char *s, const char *p) {
        if (*p == '\0') return *s == '\0';
        // next char is not '*', then must match current character
        if (*(p + 1) != '*') {
            if (*p == *s || (*p == '.' && *s != '\0'))
                return isMatch(s + 1, p + 1);
            else
                return false;
        } else { // next char is '*'
            while (*p == *s || (*p == '.' && *s != '\0')) {
                if (isMatch(s, p + 2))
                    return true;
                s++;
            }
            return isMatch(s, p + 2);
        }
    }
};
```

Ex4:[Leetcode:Simplify Path](http://oj.leetcode.com/problems/simplify-path/)  
在每次碰到/之前，都将前面的字符串保存起来；碰到/或者遍历到路径结束，若字符串为'..'，表示上一目录；若为'.'，表示当前目录；其余情况保存路径，然后重新记录。
```cpp
class Solution {
public:

    string simplifyPath(string path) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        vector<string> pathes;
        string seg = "";
        for (int i = 0; i <= path.size(); ++i) {
            if (i == path.size() || path[i] == '/') {
                if (seg == "..") {
                    if (pathes.size() > 0) {
                        pathes.pop_back();
                    } else {
                        //return "/";//error, in the test set, this case just ignore
                    }
                } else if (seg == ".") {
                    //do nothing
                } else if (seg.size() > 0) {
                    pathes.push_back(seg);
                }
                seg = "";
            } else {
                seg += path[i];
            }
        }
        string ret = "/";
        for (int i = 0; i < pathes.size(); ++i) {
            if (i > 0) ret += "/";
            ret += pathes[i];
        }
        return ret;
    }
};
```

Ex5:[Leetcode:Evaluate Reverse Polish Notation](http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/)  
一个栈保存操作数，当遇到操作符是，弹出两个操作数，计算完后将结果压入栈  
```java 
public class Solution {
    public int evalRPN(String[] tokens) {
 
        int returnValue = 0;
 
        String operators = "+-*/";
 
        Stack<String> stack = new Stack<String>();
 
        for(String t : tokens){
            if(!operators.contains(t)){
                stack.push(t);
            }else{
                int a = Integer.valueOf(stack.pop());
                int b = Integer.valueOf(stack.pop());
                int index = operators.indexOf(t);
                switch(index){
                    case 0:
                        stack.push(String.valueOf(a+b));
                        break;
                    case 1:
                        stack.push(String.valueOf(b-a));
                        break;
                    case 2:
                        stack.push(String.valueOf(a*b));
                        break;
                    case 3:
                        stack.push(String.valueOf(b/a));
                        break;
                }
            }
        }
 
        returnValue = Integer.valueOf(stack.pop());
 
        return returnValue;
 
    }
}
```
Ex6:[Leetcode:Decode Ways](http://oj.leetcode.com/problems/decode-ways/)  
每次遍历时，pre表示上上次解码方法总数，cur表示上次解码总数。假设当前解码方法数为sum，每次遍历初始化sum为0，若当前字符可以被单独解码，sun+=cur，否则sum+=0；若当前字符和上一个字符可以共同解码，sum+=pre，否则sum+=0。计算完之后，pre=cur，cur=sum  
```cpp
class Solution {
public:

    int numDecodings(const string &s) {
        if (s.empty() || s[0] == '0') return 0;
        int prev = 0;
        int cur = 1;
        // 长度为n 的字符串，有n+1 个阶梯
        for (size_t i = 1; i <= s.size(); ++i) {
            if (s[i - 1] == '0') cur = 0;
            if (i < 2 || !(s[i - 2] == '1' ||
                    (s[i - 2] == '2' && s[i - 1] <= '6')))
                prev = 0;
            int tmp = cur;
            cur = prev + cur;
            prev = tmp;
        }
        return cur;
    }
};
```

Ex7:[Leetcode:Text Justification](http://oj.leetcode.com/problems/text-justification/)  
对于每一行都贪婪的加入尽可能多的单词，然后对于多余的空格左对齐插入  
```java
public class Solution {
    public static ArrayList<String> fullJustify(String[] words, int L) {  
        ArrayList<String> ret = new ArrayList<String>();  
        int wordsLen = words.length;    // 单词数组的长度  
        int curWordIdx = 0;     // 处理第i个单词  
        while(curWordIdx < wordsLen){        // 处理完所有单词后退出  
            int charLen = 0;  // 当前行累积的字符数量  
            int probeWordIdx = curWordIdx;  
            while(probeWordIdx<wordsLen && charLen+words[probeWordIdx].length()<=L){  // 贪婪加入尽可能多的单词  
                charLen += ((words[probeWordIdx++]).length()+1);        // 累积单词长度和至少要有一个空格  
            }  
            if(probeWordIdx-curWordIdx == 1){       // tmpWordIdx-curWordIdx: 该行放入单词的数目，如果只有一个单词要特殊处理  
                String tmp = words[curWordIdx]; // 唯一的那个单词  
                tmp = addSpace(tmp, L-words[curWordIdx].length());  // 那个单词后面都接上空格  
                ret.add(tmp);  
                curWordIdx = probeWordIdx;      // 更新curWordIdx，因为已经处理好当前行了  
                continue;  
            }  
              
            // tmpWordIdx-curWordIdx: 该行放入单词的数目，也就是紧接的空格的数量（因为每个单词后接一个空格）  
            // wordCharLen：当前行所有由单词组成的字符数量（不包括空格）  
            int wordCharLen = charLen - (probeWordIdx-curWordIdx);        
            //meanSpace: 平均每个单词后的空格,tmpWordIdx<wordsLen 表示不是最后一行  
            int meanSpace = probeWordIdx<wordsLen ? (L-wordCharLen)/(probeWordIdx-curWordIdx-1) : 1;  
            //leftSpace: 多余的空格  
            int leftSpace = probeWordIdx<wordsLen ? (L-wordCharLen)%(probeWordIdx-curWordIdx-1) : L-wordCharLen-(probeWordIdx-curWordIdx-1);  
            String tmp = new String();  
            for(int k=curWordIdx; k<probeWordIdx-1; k++){    // 对当前行最后一个单词特殊处理  
                tmp += words[k];  
                tmp = addSpace(tmp, meanSpace);  
                if(probeWordIdx<wordsLen && leftSpace>0){ // 因为居中对齐  
                    tmp += " ";  
                    leftSpace--;  
                }  
            }  
            tmp += words[probeWordIdx-1];       // 处理当前行的最后一个单词  
            if(leftSpace > 0){       // 因为左对齐，所以在最后补上剩下的空格  
                tmp = addSpace(tmp, leftSpace);  
            }  
            ret.add(tmp);  
            curWordIdx = probeWordIdx;      // 处理下一行的要处理的单词  
        }  
        return ret;  
    }  
      
    public static String addSpace(String s, int count){  
        for(int i=1; i<=count; i++){  
            s += " ";  
        }  
        return s;  
    }  
}
```
Ex8:[Leetcode:Max Points on a Line](http://oj.leetcode.com/problems/max-points-on-a-line/)  
```cpp
class Solution {
public:

    int maxPoints(vector<Point> &points) {
        if (points.size() == 0)
            return 0;
        if (points.size() == 1)
            return 1;
        int result = 0;
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                bool flag = false;
                int cnt = 0;
                int a, b, c, d;
                if (points[i].x == points[j].x)
                    flag = true;
                else {
                    a = points[j].x * points[i].y;
                    b = points[i].x * points[j].y;
                    c = points[j].x - points[i].x;
                    d = points[j].y - points[i].y;
                }
                for (int k = 0; k < points.size(); k++) {
                    if (flag && points[k].x == points[i].x)
                        cnt++;
                    if (!flag && (a + d * points[k].x == b + c * points[k].y))
                        cnt++;
                }
                result = max(result, cnt);
            }
        }
        return result;
    }
};
```
