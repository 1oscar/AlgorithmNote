##2.String dp and Array dp$keywords dp  
###*String dp  
dp有几种用途，其中之一就是标记  
Ex1：[LeetCode:Palindrome Partitioning](http://oj.leetcode.com/problems/palindrome-partitioning/)  
该题dp的作用就是标记和剪枝，使用二维dp[i][len]来表示i i+len-1之间是否有继续搜索的必要，即是否可以将i i+len-1之间的串切成回文。
标记是在搜索之前判断的，之后就可dfs来搜索  
```java
public class Solution {
    ArrayList<ArrayList<String>> all = new ArrayList<ArrayList<String>>();

	public ArrayList<ArrayList<String>> partition(String s) {
		all.clear();
		int length = s.length();
		boolean[][] seg = new boolean[length][length + 1];
		for (int len = 1; len <= length; len++) {
			for (int i = 0; i < length - len + 1; i++) {
				String t = s.substring(i, i + len);
				if (isPalindrome(t)) {
					seg[i][len] = true;
					continue;
				}
				for (int k = 1; k < len; k++) {
					if (seg[i][k] && seg[i + k][len - k]) {
						seg[i][len] = true;
						break;
					}
				}
			}
		}

		part(s, seg, 0, 0, new ArrayList<String>());
		return all;
	}

	public void part(String s, boolean[][] seg, int start, int depth,
			ArrayList<String> list) {
		int length = s.length();
		if (depth == length) {
			ArrayList<String> listCopy = new ArrayList<String>(list);
			all.add(listCopy);

			return;
		}
		for (int len = 1; len <= length; len++) {
			if (seg[start][len]) {
				String word = s.substring(start, start + len);
				// System.out.println(word);
				if (isPalindrome(word)) {
					list.add(word);
					part(s, seg, start + len, start + len, list);
					list.remove(list.size() - 1);
				}
			}
		}

	}

	public boolean isPalindrome(String s) {
		for (int i = 0; i < s.length() / 2; i++)
			if (s.charAt(i) != s.charAt(s.length() - i - 1))
				return false;
		return true;
	}
}
```  
dp的作用其二，记录状态。一般记录int状态或boolean状态，下一个状态由上一个状态得到，二维dp[i][j]中的i j也不再局限于字符串的数组下标i j，而有可能是从0到某个最大值，或者从0到某个最大和  
Ex2：[Interleaving String](http://oj.leetcode.com/problems/interleaving-string/)  
此题中dp[i][j]表达的意思是s3中的前（i+j）长度串是否为 s1中的前i长度串 与 s2中的前j长度串 混合组成，使用boolean记录。
若s3的i+j-1串已经和s1的i串与s2的j-1串匹配，此时若s2的第j-1个字符和s3的第i+j-1个字符相等，则说明s3的i+j串和s1的i串与s2的j串匹配  
```java  
public class Solution {
	public boolean isInterleave(String s1, String s2, String s3) {
		if (s3.length() != s1.length() + s2.length())
			return false;
		if (s1.length() == 0)
			if (!s2.equals(s3))
				return false;
			else
				return true;
		if (s2.length() == 0)
			if (!s1.equals(s3))
				return false;
			else
				return true;
		boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
		dp[0][0] = true;

		for (int i = 1; i <= s1.length(); i++)
			if (dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1))
				dp[i][0] = true;

		for (int j = 1; j <= s2.length(); j++)
			if (dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1))
				dp[0][j] = true;

		for (int i = 1; i <= s1.length(); i++)
			for (int j = 1; j <= s2.length(); j++) {
				if (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
				if (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
			}

		return dp[s1.length()][s2.length()];
	}

	public static void main(String[] args) {
		Solution m = new Solution();
		String s1 = "aabccabc";
		String s2 = "dbbabc";
		String s3 = "aabdbbccababcc";
		boolean result = m.isInterleave(s1, s2, s3);
		System.out.print(result);
	}
}
```  
