##2.String dp and Array dp$keywords dp  
###*String dp  
dp有几种用途，其中之一就是标记  
Ex1：[LeetCode:Palindrome Partitioning](http://oj.leetcode.com/problems/palindrome-partitioning/)  
该题dp的作用就是标记，使用二维dp[i][j]来表示i j之间是否有继续搜索的必要，即是否可以将i j之间的串切成回文  
标记是在搜索之前判断的，之后就可dfs来搜索  
```java
public class Solution {
    ArrayList<ArrayList<String>> all = new ArrayList<ArrayList<String>>();

	public ArrayList<ArrayList<String>> partition(String s) {
		all.clear();
		int length = s.length();
		boolean[][] seg = new boolean[length][length + 1];
		for (int len = 1; len <= length; len++) {
			for (int i = 0; i < length - len + 1; i++) {
				String t = s.substring(i, i + len);
				if (isPalindrome(t)) {
					seg[i][len] = true;
					continue;
				}
				for (int k = 1; k < len; k++) {
					if (seg[i][k] && seg[i + k][len - k]) {
						seg[i][len] = true;
						break;
					}
				}
			}
		}

		part(s, seg, 0, 0, new ArrayList<String>());
		return all;
	}

	public void part(String s, boolean[][] seg, int start, int depth,
			ArrayList<String> list) {
		int length = s.length();
		if (depth == length) {
			ArrayList<String> listCopy = new ArrayList<String>(list);
			all.add(listCopy);

			return;
		}
		for (int len = 1; len <= length; len++) {
			if (seg[start][len]) {
				String word = s.substring(start, start + len);
				// System.out.println(word);
				if (isPalindrome(word)) {
					// System.out.println(start + " " + start + len);
					list.add(word);
					part(s, seg, start + len, start + len, list);
					list.remove(list.size() - 1);
				}
			}
		}

	}

	public boolean isPalindrome(String s) {
		for (int i = 0; i < s.length() / 2; i++)
			if (s.charAt(i) != s.charAt(s.length() - i - 1))
				return false;
		return true;
	}
}
```  
dp的作用其二，记录状态。一般记录int状态或boolean状态，下一个状态由上一个状态得到，二维dp[i][j]中的i j也不再局限于字符串的数组下标i j，而有可能是从0到某个最大值，或者从0到某个最大和  
Ex2：[Interleaving String](http://oj.leetcode.com/problems/interleaving-string/)  
此题中dp[i][j]表达的意思是s3中的前（i+j）长度串是否为 s1中的前i长度串 与 s2中的前j长度串 混合组成，使用boolean记录。
