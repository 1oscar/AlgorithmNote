##2.String dp and Array dp$keywords dp  
###*String dp  
dp有几种用途，其中之一就是标记  
Ex1：[LeetCode:Palindrome Partitioning](http://oj.leetcode.com/problems/palindrome-partitioning/)  
该题dp的作用就是标记和剪枝，使用二维dp[i][len]来表示i i+len-1之间是否有继续搜索的必要，即是否可以将i i+len-1之间的串切成回文。
标记是在搜索之前判断的，之后就可dfs来搜索  
```java
public class Solution {
    ArrayList<ArrayList<String>> all = new ArrayList<ArrayList<String>>();

	public ArrayList<ArrayList<String>> partition(String s) {
		all.clear();
		int length = s.length();
		boolean[][] seg = new boolean[length][length + 1];
		for (int len = 1; len <= length; len++) {
			for (int i = 0; i < length - len + 1; i++) {
				String t = s.substring(i, i + len);
				if (isPalindrome(t)) {
					seg[i][len] = true;
					continue;
				}
				for (int k = 1; k < len; k++) {
					if (seg[i][k] && seg[i + k][len - k]) {
						seg[i][len] = true;
						break;
					}
				}
			}
		}

		part(s, seg, 0, 0, new ArrayList<String>());
		return all;
	}

	public void part(String s, boolean[][] seg, int start, int depth,
			ArrayList<String> list) {
		int length = s.length();
		if (depth == length) {
			ArrayList<String> listCopy = new ArrayList<String>(list);
			all.add(listCopy);

			return;
		}
		for (int len = 1; len <= length; len++) {
			if (seg[start][len]) {
				String word = s.substring(start, start + len);
				// System.out.println(word);
				if (isPalindrome(word)) {
					list.add(word);
					part(s, seg, start + len, start + len, list);
					list.remove(list.size() - 1);
				}
			}
		}

	}

	public boolean isPalindrome(String s) {
		for (int i = 0; i < s.length() / 2; i++)
			if (s.charAt(i) != s.charAt(s.length() - i - 1))
				return false;
		return true;
	}
}
```  
dp的作用其二，记录状态。一般记录int状态或boolean状态，下一个状态由上一个状态得到，二维dp[i][j]中的i j也不再局限于字符串的数组下标i j，而有可能是从0到某个最大值，或者从0到某个最大和  
Ex2：[Interleaving String](http://oj.leetcode.com/problems/interleaving-string/)  
此题中dp[i][j]表达的意思是s3中的前（i+j）长度串是否为 s1中的前i长度串 与 s2中的前j长度串 混合组成，使用boolean记录。
若s3的i+j-1串已经和s1的i串与s2的j-1串匹配，此时若s2的第j-1个字符和s3的第i+j-1个字符相等，则说明s3的i+j串和s1的i串与s2的j串匹配  
```java  
public class Solution {
	public boolean isInterleave(String s1, String s2, String s3) {
		if (s3.length() != s1.length() + s2.length())
			return false;
		if (s1.length() == 0)
			if (!s2.equals(s3))
				return false;
			else
				return true;
		if (s2.length() == 0)
			if (!s1.equals(s3))
				return false;
			else
				return true;
		boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
		dp[0][0] = true;

		for (int i = 1; i <= s1.length(); i++)
			if (dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1))
				dp[i][0] = true;

		for (int j = 1; j <= s2.length(); j++)
			if (dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1))
				dp[0][j] = true;

		for (int i = 1; i <= s1.length(); i++)
			for (int j = 1; j <= s2.length(); j++) {
				if (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
				if (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))
					dp[i][j] = true;
			}

		return dp[s1.length()][s2.length()];
	}

	public static void main(String[] args) {
		Solution m = new Solution();
		String s1 = "aabccabc";
		String s2 = "dbbabc";
		String s3 = "aabdbbccababcc";
		boolean result = m.isInterleave(s1, s2, s3);
		System.out.print(result);
	}
}
```  
Ex3：[Wildcard Matching](http://oj.leetcode.com/problems/wildcard-matching/)  
又是一道字符串匹配的题。这道题dp[j][i]表达的意思是s1长度为i的串是否和s2中长度为j的串匹配。但这道题有一个小技巧，就是用s2的字符去匹配s1的字符。当s2的第j个字符是\*时，这里有两种选择：既可以让\*去匹配s1的一个字符，使i前进1，也可以把*当成空白，此时dp[j][i]的状态就等于dp[j-1][i]的状态。当s2遇到?时，和s1的第i个字符与s2的第j个字符相等是等效的，此时dp[j][i]=dp[j-1][i-1]  
```cpp  
class Solution {   
public:   
  
    bool isMatch(const char *s, const char *p) {   
        int len_s = strlen(s);   
        int len_p = strlen(p);   
  
        const char* tmp = p;   
        int cnt = 0;   
        while (*tmp != '\0') if (*(tmp++) != '*') cnt++;   
        if (cnt > len_s) return false;   
           
        bool dp[500][500];   
        memset(dp, 0,sizeof(dp));   
  
        dp[0][0] = true;   
        for (int i = 1; i <= len_p; i++) {   
            if (dp[0][i-1] && p[i-1] == '*') dp[0][i] = true;   
            for (int j = 1; j <= len_s; ++j)   
            {   
                if (p[i-1] == '*') dp[j][i] = (dp[j-1][i] || dp[j][i-1]);   
                else if (p[i-1] == '?' || p[i-1] == s[j-1]) dp[j][i] = dp[j-1][i-1];   
                else dp[j][i] = false;   
            }   
        }   
        return dp[len_s][len_p];   
    }   
};   
```  
Ex4：[Edit Distance](http://oj.leetcode.com/problems/edit-distance/)
两个字符串的最小距离。在本题中，dp同时起到了标记和记录状态的作用，表示s1中前面长度为i的串和s2中前面长度为j的串匹配的最小距离。用过dfs的同学都知道，一般dfs是当遍历到末尾才开始返回值的，本题dfs的目的就是返回dp[i][j]的最小值。既然返回的是最小值，所以对于每一个dp[i][j]来说，只要遍历过一遍就够了，第一次遍历赋值，第二次遍历到dp[i][j]直接返回dp[i][j]的值。然后关注当前状态dp[i][j]。若s1中第i个字符和s2中第j个字符相等，dp[i][j]=dp[i-1][j-1]，自然不用说；若不相等，则分成了增删改三种情况：增的话j+1，相当于在s1中加了一个字符与s2中第j个字符匹配；删，i+1，s1第i个字符被删掉，用s1第i+1个与s2第j个字符匹配；改，改后s1第i个字符等于s2第j个字符，i+1，j+1。以上三种情况匹配距离都要加一。然后取出三者中小的赋给dp[i][j]。   
```java  
public class Solution {
	public int minDistance(String word1, String word2) {
		if (word1.length() == 0)
			return word2.length();
		if (word2.length() == 0)
			return word1.length();
		int[][] dp = new int[word1.length()][word2.length()];
		int result = search(0, 0, word1, word2, dp);
		return result;
	}

	public int search(int i, int j, String s1, String s2, int[][] dp) {
		if (i == s1.length())
			return s2.length() - j;
		if (j == s2.length())
			return s1.length() - i;
		if (dp[i][j] != 0)
			return dp[i][j];
		if (s1.charAt(i) == s2.charAt(j)) {
			int tmp = search(i + 1, j + 1, s1, s2, dp);
			dp[i][j] = tmp;
			return tmp;
		}
		int tmp1 = search(i, j + 1, s1, s2, dp) + 1;
		int tmp2 = search(i + 1, j, s1, s2, dp) + 1;
		int tmp3 = search(i + 1, j + 1, s1, s2, dp) + 1;
		int result = tmp1;
		if (result > tmp2)
			result = tmp2;
		if (result > tmp3)
			result = tmp3;
		dp[i][j] = result;
		return result;
	}
}
```
